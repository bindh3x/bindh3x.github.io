<!doctype html>
<html lang="he">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="בלוג Unix, פיתוח תכנה ואבטחת מידע.">
    <meta name="author" content="bindh3x">
    <meta name="robots" content="noarchive" />
    <link rel="icon" href="/favicon.ico">

    <title>bindh3x.io > איך לתקן באג בתכנה</title>

    <link href="/style.css" rel="stylesheet">
  </head>
  <body>
    <!-- Navbar -->
    <nav class="navbar clearfix">
      <div class="container">

	<div class="navbar-brand">
	  <a href="/">bindh3x.io</a>
	</div>

	<ul class="navbar-right">
	  <li><a href="/">בלוג</a></li>
	  <li><a href="/about/">אודות</a></li>
	</ul>

	<ul class="navbar-left">
	  <li><a href="/rss.xml">rss</a></li>
	</ul>

      </div>
    </nav>

    <main role="main" class="container">
      <div class="post">
	<div class="post-info">
	  <time datetime="1595443092">
	    22/07/2020
	  </time>
	</div>

	<h1 class="post-title">איך לתקן באג בתכנה</h1>
	<div class="post-line"></div>

	<p>מאוד כיף לשבת ולכתוב קוד באופן ספונטני מבלי לתכנן שוב דבר, כשמדובר בסקריפט קצר זה גם לא כזה קריטי.
אבל כשהקוד שלנו עושה פעולה מורכבת, חשוב לשבת ולתכנן לפני המימוש. ההבדל בין תכנה טובה, לגרועה  מסתכם
בארכיטקטורה. אם אתם לא מבינים מה אתם צריכים לממש ומהי הצורה היעילה ביותר לעשות זאת, איך תכתבו את הקוד?
כן אתם יכולים לכתוב קוד "שיעשה את העבודה", אבל מה יקרה כשתצטרכו להתמודד עם בעיות שלא חשבתם עליהם?
מה יקרה כשבסיס המשתמשים שלכם יגדל, והקוד שלכם לא יעמוד בעומס? מכירים את המשפט "כשנגיע לגשר נחצה אותו"?
אז זה מה שאתם <em>לא</em> רוצים להגיד לעצמכם בפיתוח תכנה, מפני ש<strong>בעיה פותרים פעם אחת</strong>.
אתם יכולים לחבוש יד שבורה, אך אם לא קיבעתם אותה יהיו לכך השלכות. בעיות פותרים מהשורש.</p>

<p>תמיד תתכננו את האלגוריתם לפני שאתם כותבים את הקוד. ואחרי שאתם עושים את זה, תנסו לשבור את הקוד שלכם,
מה יקרה אם האלגוריתם יקבל 1000 נתונים, מיליון או מיליארד? גם אם התכנית שלכם לא תצטרך להתמודד עם כמות
עצומה של מידע, חשיבה מעמיקה (באופן תיאורטי) על הקוד שלכם תגרום לכם לכתוב קוד עם פחות באגים, עמיד יותר
ושאתם אשכרה יודעים מה הוא עושה. הנקודה האחרונה חשובה מאוד.
למדתי לתכנת בגיל מאוד צעיר, ואני זוכר שכהייתי נתקל בבאגים הצורה שבה היתי פותר אותם היתה מאוד לא יעילה:
בתקופה ההיא כל מה שרציתי זה "לכתוב קוד שיעשה משהו" - לא באמת היה אכפת לי אם המימוש היה
נכון. אם משהו לא היה עובד לי, הייתי משנה ערכים של משתנים ומשחק עם הקוד עד שהוא היה עובד באורח נס.
לא באמת הייתי מבין למה הבאג תוקן אבל היי! לפחות הקוד עושה מה שאני רוצה.</p>

<p>אחת מן הטעויות הכי קריטיות שאתם יכולים לעשות כאשר אתם נתקלים בבאג היא <strong>לשכתב את הקוד מחדש</strong>.
כי אז לא באמת למדתם כלום. יש באגים שיקח לכם הרבה מאוד זמן לתקן ולהבין למה הם קרו. כשמדובר בבאג
עקשן, קל מאוד להתייאש ולטרוף את הקלפים אך זה לא הפתרון.
ברוב המקרים הבאג יווצר בגלל משהו קטן, לפעמים זה יקרה בגלל שאתם לא מבינים את השפה או מערכת ההפעלה
שאיתה אתם עובדים, מהסיבה הזאת חשוב לקרוא את המסמכים הרלוונטים, לעצור ולחשוב.</p>

<p>החודש נתקלתי בבאג מעניין בקוד שכתבתי. שדה במבנה נתונים מסוים היה משתנה לערכים לא צפויים במהלך ריצת התכנית.
הבאג היה קורה רק במצבים מאוד ספציפים, ההנחות הראשונות שלי היו:</p>

<ul>
<li>שאני לא מאתחל זכרון כלשהו.</li>
<li>שיש איזשהו overflow או memory leak שגורמים להשחתת זכרון.</li>
</ul>

<p>כשאני מנסה להבין למה קוד מסוים לא עובד כשורה, אני מתחיל בלהסיר קוד לא רלוונטי עד שנשאר לי שלד של התכנית המקורית.
קוד שלא קשור לבעיה, מוחלף ב - <a href="https://en.wikipedia.org/wiki/Method_stub">stubs</a>. וכך אני בודק שכבה אחר
שכבה עד שאני מגיע לבעיית השורש. אם יש צורך אני גם
משתמש ב - <a href="https://en.wikipedia.org/wiki/GNU_Debugger">gdb</a> ו - <a href="https://en.wikipedia.org/wiki/Valgrind">valgrind</a>.
הדברים הראשונים שבדקתי בקוד שלי, היו: איפה אני משנה את מבנה הנתונים הבעייתי, האם אני דורס את המחסנית?
האם יש לי memory leak? כל הבדיקות הנ"ל העלו חרס. אם אני לא משחית את הזכרון, למה השדה במבנה הנתונים
מקבל ערך לא צפוי במהלך ריצת התכנית? אני אחסוך מכם את הפרטים הלא מעניינים, ויגיע לעיקר: בסופו של דבר הבנתי
מה קרה. הבעיה היתה נעוצה באופן ש -  <code>malloc(3)</code> ממומשת במערכת ההפעלה <a href="https://en.wikipedia.org/wiki/OpenBSD">OpenBSD</a>.</p>

<h3>malloc(3)</h3>

<p>כאשר זכרון מוקצה ומשוחרר עם <code>free(3)</code> הוא לא באמת משוחרר. כלומר הוא מסומן כמשוחרר על ידי <code>malloc(3)</code> ומוחזר ל - <code>pool</code>
של זכרון חופשי, כך שבפועל אנחנו לא מבקשים מהקרנל לשחרר את הזכרון והוא מוחזק לשימוש עתידי. הסיבה לכך מאוד פשוטה: הקצאת
זכרון כרוכה ב - <a href="https://en.wikipedia.org/wiki/Context_switch">context switch</a> שנחשב לתהליך יקר,  ולכן עדיף פשוט להשאיר זכרון שהוקצה ב - <code>pool</code> ולהקצות אותו מחדש במידת הצורך, במקום לבקש עוד זכרון מהקרנל.
זוהי טכניקה שמהווה בסיס ל - <a href="https://en.wikipedia.org/wiki/Slab_allocation">slab allocation</a>.</p>

<p>ב - OpenBSD, נכתבים לזכרון המשוחרר "junk bytes" (0xdb בהקצאה, ו - 0xdf בשחרור זכרון) על מנת להבטיח
שהנתונים הקודמים שהוקצו, לא יהיו זמינים בהקצאה הבאה. ולכן כל פעם שהייתי קורא לפונקציה <code>free</code> הזכרון שהייתי מקבל בהקצאה
הבאה הכיל "junk bytes", ובגלל שלא אתחלתי  את מבנה הנתונים לפני השימוש הייתי מקבל התנהגות בלתי צפויה.</p>

<h3>מסקנות</h3>

<p>אני אוהב שצצות לי בעיות בקוד, כי אני תמיד לומד מזה משהו. יכלתי לאתחל את מבנה הנתונים בהתחלה
ולפתור את הבאג מבלי לבזבז זמן, אבל רציתי לדעת למה אני <em>צריך</em> לאתחל אותו, אין צורך לאפס מבנה נתונים כל פעם שאנחנו
מקצים זכרון (במיוחד במערכות שדורשות ביצועים גבוהים).</p>

<p>אם הייתי קורא את ה - man page של <code>malloc(3)</code> במלואו, הייתי פותר את הבאג תוך כמה דקות אז אם אתם גם נתקלים
בבאג מוזר - RTF. זה יחסוך לכם הרבה מאוד זמן.</p>

    </div>


    </main>

    <!-- Footer -->
    <footer class="site-footer">
      <div class="container">
	<p>Copyright &copy; 2017-2020 bindh3x</p>
	<p>Licensed under <a href="https://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0</a>
      </div>
    </footer>


  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-103398205-1">
  </script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-103398205-1');
  </script>
  </body>
</html>

